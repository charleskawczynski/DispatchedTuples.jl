var documenterSearchIndex = {"docs":
[{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"DispatchedTuples.AbstractDispatchedTuple\nDispatchedTuples.DispatchedTuple\nDispatchedTuples.DispatchedSet\nDispatchedTuples.dispatch","category":"page"},{"location":"api/#DispatchedTuples.AbstractDispatchedTuple","page":"API","title":"DispatchedTuples.AbstractDispatchedTuple","text":"AbstractDispatchedTuple{T <: Tuple, D}\n\nAn abstract dispatch tuple type, for sub-typing dispatched tuples.\n\n\n\n\n\n","category":"type"},{"location":"api/#DispatchedTuples.DispatchedTuple","page":"API","title":"DispatchedTuples.DispatchedTuple","text":"DispatchedTuple(tup[, default_value])\n\nA dispatch-able tuple.\n\nDispatchedTuple takes a Tuple of Pairs, where the first field of the Pair (the \"key\") is an instance of the type you want to dispatch on. The second field of the Pair is the quantity (the \"value\", which can be anything) returned by dispatch.\n\nIf a DispatchedTuple has non-unique keys, then all values are returned in the returned Tuple.\n\nThe second (optional) argument to DispatchedTuple is a default value, which is returned for any unrecognized keys. If the default value is not given, then dispatch on an unregistered key will return an empty tuple.\n\nFor convenience, DispatchedTuple can alternatively take a Tuple of two-element Tuples.\n\nExample\n\nusing DispatchedTuples\nstruct Foo end;\nstruct Bar end;\nstruct Baz end;\n\ndtup = DispatchedTuple((\n   Pair(Foo(), 1),\n   Pair(Foo(), 2),\n   Pair(Bar(), 3),\n));\n\ndispatch(dtup, Foo()) # returns (1, 2)\ndispatch(dtup, Bar()) # returns (3,)\ndispatch(dtup, Baz()) # returns ()\n\n\n\n\n\n","category":"type"},{"location":"api/#DispatchedTuples.DispatchedSet","page":"API","title":"DispatchedTuples.DispatchedSet","text":"DispatchedSet(tup[, default_value])\n\nSimilar to DispatchedTuple, except:\n\nkeys must be unique.\nreturns the value, and not a tuple of values.\nthrows an error in dispatch if the key is not unique (without a default value).\n\n\n\n\n\n","category":"type"},{"location":"api/#DispatchedTuples.dispatch","page":"API","title":"DispatchedTuples.dispatch","text":"dispatch(::DispatchedTuple, type_instance)\n\nDispatch on the DispatchedTuple, based on the instance of the input type type_instance.\n\n\n\n\n\ndispatch(::DispatchedSet, type_instance)\n\nDispatch on the DispatchedSet, based on the instance of the input type type_instance.\n\n\n\n\n\n","category":"function"},{"location":"performance/#Performance","page":"Performance","title":"Performance","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"The performance of DispatchedTuples should scale similar to the performance of ordinary tuples (good with small tuples, but expensive with larger ones).","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"using DispatchedTuples\nusing InteractiveUtils\n\nstruct Foo end;\nstruct Bar end;\nstruct Baz end;\n\ntup = (\n   Pair(Foo(), 1),\n   Pair(Bar(), 3),\n   Pair(Foo(), 2),\n)\n\ntupset = (\n   Pair(Foo(), 1),\n   Pair(Bar(), 3),\n   Pair(Baz(), 2),\n)\ndtup = DispatchedTuple(tup);\ndset = DispatchedSet(tupset);\nnothing","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"Using dispatch on a DispatchedTuple is equivalent to hard-coding the intended indexes ahead of time, which means that the LLVM code is concise:","category":"page"},{"location":"performance/#DispatchedTuple","page":"Performance","title":"DispatchedTuple","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"get_foo_magic(dtup) = (dtup.tup[1][2], dtup.tup[3][2])\n@code_typed get_foo_magic(dtup)","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"@code_typed dispatch(dtup, Foo())","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"@code_native get_foo_magic(dtup)","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"@code_native dispatch(dtup, Foo())","category":"page"},{"location":"performance/#DispatchedSet","page":"Performance","title":"DispatchedSet","text":"","category":"section"},{"location":"performance/","page":"Performance","title":"Performance","text":"get_foo_magic(dset) = dset.tup[1][2]\n@code_typed get_foo_magic(dset)","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"@code_typed dispatch(dset, Foo())","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"@code_native get_foo_magic(dset)","category":"page"},{"location":"performance/","page":"Performance","title":"Performance","text":"@code_native dispatch(dset, Foo())","category":"page"},{"location":"#DispatchedTuples.jl","page":"Home","title":"DispatchedTuples.jl","text":"","category":"section"},{"location":"#What-are-dispatched-tuples?","page":"Home","title":"What are dispatched tuples?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DispatchedTuples are like immutable dictionaries (so, they're more like NamedTuples) except that the keys are instances of types. Also, because DispatchedTuples are backed by tuples, they are GPU-friendly.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are two kinds of DispatchedTuples with different behavior:","category":"page"},{"location":"","page":"Home","title":"Home","text":"┌────────────────────────────────────┬───────────────────────────┬────────────────────┐\n│                       Return value │           DispatchedTuple │ DispatchedSet      │\n│                                    │ (non-unique keys allowed) │ (unique keys only) │\n├────────────────────────────────────┼───────────────────────────┼────────────────────┤\n│                               Type │                     Tuple │              Value │\n│ Unregistered key (without default) │                        () │              error │\n│    Unregistered key (with default) │                (default,) │            default │\n│                    Duplicative key │     all registered values │          one value │\n└────────────────────────────────────┴───────────────────────────┴────────────────────┘","category":"page"},{"location":"#Creating-and-using-dispatched-tuples","page":"Home","title":"Creating and using dispatched tuples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All AbstractDispatchedTuples take a Tuple of Pairs, where the first field of the Pair (the \"key\") is an instance of the type you want to dispatch on. The second field of the Pair is the quantity (the \"value\", which can be anything) returned by dispatch(::AbstractDispatchedTuple, key), the one user-facing method exported by DispatchedTuples.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Note that the second (optional) argument to DispatchedTuple and DispatchedSet is a default value, which is returned for any unrecognized keys as shown in the table above.","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Here is an example in action","category":"page"},{"location":"","page":"Home","title":"Home","text":"using DispatchedTuples\nstruct Foo end;\nstruct Bar end;\nstruct Baz end;\n\ndtup = DispatchedTuple((\n   Pair(Foo(), 1),\n   Pair(Foo(), 2),\n   Pair(Bar(), 3),\n));\n\ndispatch(dtup, Foo()) # returns (1, 2)\ndispatch(dtup, Bar()) # returns (3,)\ndispatch(dtup, Baz()) # returns ()","category":"page"},{"location":"","page":"Home","title":"Home","text":"For convenience, DispatchedTuple can alternatively take a Tuple of two-element Tuples.","category":"page"}]
}
